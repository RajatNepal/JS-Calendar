function get_token_cookie() {

        //Code taken from Mozilla
    //https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie
    let cookieValue = document.cookie.split('; ').find(row => row.startsWith('token='));
    //end of code citation
    
    if (cookieValue != undefined){
        return cookieValue.split('=')[1];
    }
    else {
        return null;
    }
}

function server_create_account(param, render_function) {

    if (param ==""){
        param = ["test", "test"];
    }
     //Testing by typing values in here

    let [username, password] = param; //JS array destructuring
    console.log(username+","+password);


    server_fetch("create_account", "POST", {"u":username, "p":password})
    .then(res=>res.json())
    .then((response)=>{
        console.log(JSON.stringify(response));

        if (response.success){
            render_function(JSON.stringify(response));
        }
        else{
            alert(response.description);
        }

    })
    .catch((error)=>console.error("Error",error));
}


function server_login(param, render_function) {

    if (param ==""){
        param = ["test", "test"];
    } //Testing by typing values in here

    let [username, password] = param; 
    console.log(username+","+password);

    //The csrf token will get sent in the body of the JSON from the server
    //This token will get stored in document.cookies and will be passed in with each request to the server.


    server_fetch("login", "POST", {"u":username, "p":password})
    .then(res=>res.json())
    .then((response)=>{
        const json_string = JSON.stringify(response);
        console.log(json_string);
        console.log(response);
        console.log(JSON.parse(json_string).token);

        //Adds token received from JSON to document.cookie
        document.cookie = "token= "+JSON.parse(json_string).token+";";

        if (response.success){
            render_function(username); //passing username as the data to render with
            logged_in = true;
        }
        else {
            alert(response.description);
        }
        

    })
    .catch((error)=>console.error("Error",error));

}


function server_logout(param, render_function) {

    console.log(get_token_cookie());

    server_fetch("logout", "POST", {"token":get_token_cookie()})
    .then(res=>res.json())
    .then((response)=>{
        const json_string = JSON.stringify(response);
        console.log(json_string);
        document.cookie = "token= ;"; //Sets the csrf token to "" if logout is successful
        logged_in = false;


        render_function(json_string);
    })
    .catch((error)=>console.error("Error",error)); //Should I make this catch clear the error anyways?
}

function create_event(param, render_function){
    //user, can be pulled from session in backend
    //event_id, autogenerated in mysql
    //event_title
    //event_description
    //event_date -> mysql date format 1000-01-01 Y-M-D
    //start_time -> mysql datetime format 1000-01-01 00:00:00
    //end_time -> ^same
    //timestamp_created, autogenerated in mysql
    //group_id -> int, we'll pass it as a string, then cast to int

    //For now Im going with group 1 as just not being a group


    let [event_title, event_description, event_date, event_time,  group_id, tag_name] = param;

    //These values will be parsed into the correct format for insertion into mysql on the server side

    server_fetch(
        "create_event", 
        "POST", 
        {
            "event_title":event_title, 
            "event_description":event_description,
            "event_date": event_date,
            "event_time": event_time,
            "group_id": group_id,
            "tag_name":tag_name,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        console.log(JSON.stringify(response));

        if (response.success){
            render_function(response);
        }
        else {
            alert(response.description);
        }
    })
    .catch((error)=>console.error("Error",error));
}

function edit_event(param, render_function) {
    //only need one parameter, the event_id

    //if blank for testing
    if (param ==""){
        param = ["6","Testing event tags","Hopefully editing tags works!","","","","Test"]; 
    }
    
    //We'll test by editing event # 9

    //I'll set this up on the php side such that no matter what combination of changes you pass in
    //it'll keep whats left empty as is, then update the fields which have arguments.

    let [event_id, event_title, event_description, event_date, event_time, tag_name] = param;

    server_fetch(
        "edit_event", 
        "POST", 
        {
             "event_id":event_id,
            "event_title":event_title, 
            "event_description":event_description,
            "event_date": event_date,
            "event_time": event_time,
            
            "tag_name": tag_name,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        console.log(JSON.stringify(response));
        
        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}

function delete_event(param, render_function) {
    //only need one parameter, the event_id
    //param = ["10"]; 
    //We'll test by editing event # 10

    let [event_id] = param;

    server_fetch(
        "delete_event", 
        "POST", 
        {
            "event_id": event_id,
            "token":get_token_cookie()

        })
    .then(res=>res.json())
    .then((response)=>{
        
        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}

function delete_group_event(param, render_function) {

    let [group_event_id] = param;

    server_fetch(
        "delete_group_event", 
        "POST", 
        {
            "group_event_id": group_event_id,
            "token":get_token_cookie()

        })
    .then(res=>res.json())
    .then((response)=>{
        
        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}



function user_events(param, render_function){
    //NOTE: Expand to work for a specific YEAR ALSO
    //Will return this user's events for the entire month or for some range of days within that month
    //Example: param = [["0","30"], "2"]; Calling with these parameters would return all events from day 0 to 30 of February
    //param = First tuple is the range of days that we want to pick o-ut of this month
    //Next value is the month that we want to look in
    //Pass in values based on the calendar API, I'm too lazy to math it out in the backend.

    let [range, month_num] = param;

    server_fetch(
        "user_events", 
        "POST", 
        {
            "range_start": range[0],
            "range_end": range[1],
            "month_num": month_num,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        console.log(JSON.stringify(response));
        console.log(response.events);

        if (response.success){

                render_function(response);
 
        }
        else {
            alert(response.description);
        }
    })
    .catch((error)=>console.error("Error",error));
    
}

function create_group(param, render_function){
    //Will return this user's events for the entire month or for some range of days within that month

    //Will always be done from some users account, so we'll get $user from PHP session
    
    if (param == ""){

        param = ["test_create_group_2", "Testing if creating a group, and automatically adding its owner as a user works"]; 
    
    }


    let [group_name,group_description] = param;

    server_fetch(
        "create_group", 
        "POST", 
        {
            "group_name": group_name,
            "group_description": group_description,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{

        render_function(JSON.stringify(response)); 
    })
    .catch((error)=>console.error("Error",error));
}

function edit_group(param, render_function){
    //Will return this user's events for the entire month or for some range of days within that month

    //Will always be done from some users account, so we'll get $user from PHP session
    
    if (param == ""){

        param = [2,"test_edit_group", "Testing if editing a group works"]; 
    }
    


    let [group_id,group_name,group_description] = param;

    server_fetch(
        "edit_group", 
        "POST", 
        {
            "group_id": group_id,
            "group_name": group_name,
            "group_description": group_description,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{

        render_function(JSON.stringify(response)); 
    })
    .catch((error)=>console.error("Error",error));
}


function delete_group(param, render_function) {
    //only need one parameter, the event_id

    //if empty for testing
    if (param == ""){
        param = ["11"]; 
    }
    //We'll test by editing event # 10

    let [group_id] = param;

    server_fetch(
        "delete_group", 
        "POST", 
        {
            "group_id": group_id,
            "token":get_token_cookie()

        })
    .then(res=>res.json())
    .then((response)=>{
        
        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}


function create_group_event(param, render_function){

    if (param == ""){

        param = [ "HONK HONK TEST TAG", "Twewewewe", "2022-02-28", "03:13:00", "08:13:00", "2"];

    }
    let [event_title, event_description, event_date, event_time, group_id, tag] = param;


    server_fetch(
        "create_group_event", 
        "POST", 
        {
            "event_title":event_title, 
            "event_description":event_description,
            "event_date": event_date,
            "event_time": event_time,
            "tag":tag,

            "group_id": group_id,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{


        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}


function edit_group_event(param, render_function) {
    //only need one parameter, the event_id
    

    let [group_event_id, event_title, event_description, event_date, event_time,tag_name] = param;

    console.log('group event id obtained: '+group_event_id);
    server_fetch(
        "edit_group_event", 
        "POST", 
        {
            "group_event_id":group_event_id,
            "event_title":event_title, 
            "event_description":event_description,
            "event_date": event_date,
            "event_time": event_time,
            
            "tag_name":tag_name,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        
        render_function(JSON.stringify(response));
    })
    .catch((error)=>console.error("Error",error));
}

function group_events(param, render_function){

    if (param == ""){

        param = [["24","27"], "2", "2"]; 
    }
    

    let [range, month_num, group_id] = param;

    server_fetch(
        "group_events", 
        "POST", 
        {
            "range_start": range[0],
            "range_end": range[1],
            "month_num": month_num,
            "group_id":group_id,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        console.log(response.events);

        render_function(response.events); 

    })
    .catch((error)=>console.error("Error",error));
}


function group_members(param, render_function){

    if (param == ""){
        param = ["2"]; 
    }
    
    let [group_id] = param;

    server_fetch(
        "group_members", 
        "POST", 
        {
            "group_id":group_id,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{

        //Will pass an array of all group members to the render function, 
        //the group owner will be the first item in the array, and there will be a duplicate group owner later.

        render_function(response.group_members); 
    })
    .catch((error)=>console.error("Error",error));
}


function add_user_to_group(param, render_function){

    //Not necessarily for the currently logged in user
    //If you call this method with empty parameters it will assume the current user.

    //NOTE:::: currently lets you add users to a group multiple times, clogs up the table


    //Might run a check on group_members before running this code

    if (param == ""){

        param = ["", "1"]; 
    }
    
    let [username, group_id] = param;

    server_fetch(
        "add_user_to_group", 
        "POST", 
        {
            "username":username,
            "group_id":group_id,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        render_function(response); 
    })
    .catch((error)=>console.error("Error",error));
}

function remove_user_from_group(param, render_function){

    //Not necessarily for the currently logged in user
    //If you call this method with empty parameters it will assume the current user.


    if (param == ""){

        param = ["", "1"]; 
    }
    
    let [username, group_id] = param;

    server_fetch(
        "remove_user_from_group", 
        "POST", 
        {
            "username":username,
            "group_id":group_id,
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        render_function(JSON.stringify(response)); 
    })
    .catch((error)=>console.error("Error",error));
}

function display_groups(param, render_function){
    //New one which I just added, forgot to write this earlier because I'm a dumbfuck

    param = []; //Really don't need parameters on this one

    server_fetch(
        "display_groups", 
        "POST", 
        {
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        render_function(response); 
    })
    .catch((error)=>console.error("Error",error));
}

function get_tags(param, render_function){

    //Not necessarily for the currently logged in user
    //If you call this method with empty parameters it will assume the current user.


    param = []; //No parameters needed
    

    server_fetch(
        "get_tags", 
        "POST", 
        {
            "token":get_token_cookie()
        })
    .then(res=>res.json())
    .then((response)=>{
        render_function(JSON.stringify(response)); 
    })
    .catch((error)=>console.error("Error",error));
}

function clear_log(param,render_function){
    param = [];
    document.getElementById("csrf-display").innerHTML = "";
}


async function server_fetch(endpoint, method="POST", data="", headers={"content-type": "application/json"}) {
    //Endpoint is some string which will be correspond directly to the php file we make the request to
    // Method is "GET" or "POST"

    //headers, method, data set to a default arguments

    //CSRF token will get passed into data by whatever method calls this one

    //let url = "http://ec2-44-203-76-180.compute-1.amazonaws.com/~antond/m5_group/server/"+endpoint+".php";
    let url = "http://ec2-54-159-121-198.compute-1.amazonaws.com/~rnepal/m5_group/server/"+endpoint+".php";
    console.log(url);
    let json = {"method":method,
            "body":JSON.stringify(data),
            "header":headers};

    return  fetch(url, json);
    //Returns the fetch() promise, each method which calls this can determine how they want to resolve this promise
}
